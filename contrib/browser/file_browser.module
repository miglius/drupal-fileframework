<?php
// $Id$

/**
 * @file
 * Module providing a file browser for file nodes organized in a hierarchical taxonomy tree.
 */

//////////////////////////////////////////////////////////////////////////////

define('FILE_BROWSER_FILE_LINK',         variable_get('file_browser_file_link', 'nolink'));
define('FILE_BROWSER_HIDE_EMPTY',        variable_get('file_browser_hide_empty', FALSE));
define('FILE_BROWSER_EMBED_PREVIEWS',    variable_get('file_browser_embed_previews', TRUE));
define('FILE_BROWSER_FOLDER_PROPERTIES', variable_get('file_browser_folder_properties', TRUE));
define('FILE_BROWSER_OG_VOCABULARIES',   variable_get('file_browser_og_vocabularies', 0));
define('FILE_BROWSER_OG_UPLOAD',         variable_get('file_browser_og_upload', FALSE));
define('FILE_BROWSER_OG_PREVIEW',        variable_get('file_browser_og_preview', FALSE));
define('FILE_BROWSER_OG_UNFILED',        variable_get('file_browser_og_unfiled', ''));
define('FILE_BROWSER_LOCATION_PREVIEW',  variable_get('file_browser_location_preview', FALSE));

define('FILE_BROWSER_TITLE_LENGTH',        50);
define('FILE_BROWSER_TITLE_LENGTH_SHORT',  14);
define('FILE_BROWSER_TITLE_LENGTH_BLOCK',  20);

//////////////////////////////////////////////////////////////////////////////
// CORE API HOOKS

/**
 * Implementation of hook_theme().
 */
function file_browser_theme() {
  return array(
    'file_browser_page' => array(
      'arguments' => array('data' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
    'file_browser_term' => array(
      'arguments' => array('data' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
    'file_browser_file' => array(
      'arguments' => array('data' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
    'file_browser_preview' => array(
      'arguments' => array('data' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
    'file_browser_block' => array(
      'arguments' => array('data' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
    'file_browser_newterm' => array(
      'arguments' => array('form' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
    'file_browser_upload' => array(
      'arguments' => array('form' => NULL),
      'file' => 'file_browser.theme.inc'
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function file_browser_perm() {
  return array('browse files', 'create terms', 'upload files');
}

/**
 * Implementation of hook_menu().
 */
function file_browser_menu() {
  return array(
    'admin/settings/file/browser' => array(
      'title' => 'Browser',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('file_browser_admin_settings'),
      'access arguments' => array('administer site configuration'),
      'file' => 'file_browser.admin.inc',
    ),
    'file_browser' => array(
      'title' => 'File browser',
      'page callback' => 'file_browser_page',
      'page arguments' => array(1, 2),
      'access arguments' => array('browse files'),
      'type' => MENU_NORMAL_ITEM,
    ),
    'file_browser/preview/%file' => array(
      'page callback' => 'file_browser_preview',
      'page arguments' => array(2),
      'access arguments' => array('browse files'),
      'type' => MENU_CALLBACK,
    ),
    'file_browser/ajax/term' => array(
      'page callback' => 'file_browser_ajax_term',
      'page arguments' => array(3, 4),
      'access arguments' => array('browse files'),
      'type' => MENU_CALLBACK,
    ),
    'file_browser/ajax/voc' => array(
      'page callback' => 'file_browser_ajax_voc',
      'access arguments' => array('browse files'),
      'type' => MENU_CALLBACK,
    ),
  );
}

/**
 * Implementation of hook_block().
 */
function file_browser_block($op = 'list', $delta = 0, $edit = array()) {
  if (!user_access('browse files'))
    return;

  switch ($op) {
    case 'list':
      $block = array(
        'newterm' => array(
          'info' => t('Create Term'),
          'status' => 1,
          'region' => 'right',
          'weight' => -3,
        ),
        'upload' => array(
          'info' => t('File upload'),
          'status' => 1,
          'region' => 'right',
          'weight' => -2,
        ),
        'preview' => array(
          'info' => t('File preview'),
          'status' => 1,
          'region' => 'right',
          'weight' => -1,
        ),
        'my' => array(
          'info' => t('My files'),
        ),
      );
      $vocabularies = taxonomy_get_vocabularies('file');
      foreach ($vocabularies as $vid => $vocabulary) {
        $block_info = t('@title file browser', array('@title' => $vocabulary->name));
        $block['file_browser-'. $vocabulary->vid] = array('info' => $block_info);
      }
      return $block;
    case 'configure':
      return '';
    case 'view':
      switch ($delta) {
        case 'newterm':
          $block['subject'] = check_plain(t('Create Term'));
          $block['content'] = arg(0) == 'file_browser' ? _file_browser_newterm() : NULL;
          break;
        case 'upload':
          $block['subject'] = check_plain(t('File upload'));
          $block['content'] = arg(0) == 'file_browser' ? _file_browser_upload() : NULL;
          break;
        case 'preview':
          $block['subject'] = check_plain(t('File information'));
          $block['content'] = arg(0) == 'file_browser' ? theme('file_browser_preview', array()) : NULL;
          break;
        case 'my':
          $block['subject'] = check_plain(t('My files'));
          $block['content'] = _file_browser_block('my');
          break;
        default:
          list($type, $vid) = explode('-', $delta);
          $vocabularies = taxonomy_get_vocabularies('file');
          if ($vocabulary = $vocabularies[$vid]) {
            $block['subject'] = check_plain($vocabulary->name);
            $block['content'] = _file_browser_block($vid);
          }
      }
      return $block;
  }
}

//////////////////////////////////////////////////////////////////////////////
// NODE API HOOKS

/**
 * Implementation of hook_nodeapi().
 */
function file_browser_nodeapi(&$node, $op) {
  switch ($op) {
    case 'insert':
    case 'update':
      if ($node->type == 'file' && FILE_BROWSER_OG_UNFILED)
        _file_browser_enforce_unfiled($node);
      break;
  }
}

/**
 * Get term for an unfiled folder.
 *
 * @param $vid
 *   A vocabulary ID.
 *
 * @return
 *   A term ID.
 */
function _file_browser_get_unfiled_term($vid) {
  if ($tid = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = %d AND name = '%s'", $vid, FILE_BROWSER_OG_UNFILED)))
    return $tid;

  db_query("INSERT INTO {term_data} (vid, name) VALUES (%d, '%s')", $vid, FILE_BROWSER_OG_UNFILED);
  $tid = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = %d AND name = '%s'", $vid, FILE_BROWSER_OG_UNFILED));
  db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, 0)", $tid);
  return $tid;
}

/**
 * Uncategorized files are put in unfiled folder.
 *
 * @param $node
 *   A node object.
 *
 * @return
 */
function _file_browser_enforce_unfiled(&$node) {
  if (!is_array($node->og_groups) || !module_exists('og_vocab'))
    return;

  // Normalize the $node->taxonomy array into a known-good format that we
  // can rely on for comparisons in the code further below.
  foreach ($node->taxonomy as $vid => $tids) {
    if (is_string($tids)) {
      unset($node->taxonomy[$vid]);
      if ($term = taxonomy_get_term($tids)) {
        $node->taxonomy[$term->vid] = array($term->tid => $term->tid);
      }
    }
  }

  foreach ($node->og_groups as $gid) {
    foreach (og_vocab_load_vocabularies($gid) as $vid => $vocabulary) {
      if (in_array('file', $vocabulary->nodes)) {
        if ($tid = _file_browser_get_unfiled_term($vid)) {
          // Selecting the <none> entry should have the same effect as not selecting any entry.
          if (is_array($node->taxonomy[$vid]))
            unset($node->taxonomy[$vid][""]);

          // If no categories were selected, associate the node with unfiled category:
          if (empty($node->taxonomy[$vid])) {
            db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $tid);
            $node->taxonomy[$vid] = array($tid => $tid);
          }
          // If any categories were selected, make sure the unfiled category isn't selected:
          else if (is_array($node->taxonomy[$vid]) && in_array($tid, $node->taxonomy[$vid])) {
            if (count($node->taxonomy[$vid]) > 1) {
              db_query('DELETE FROM {term_node} WHERE nid = %d AND tid = %d', $node->nid, $tid);
              unset($node->taxonomy[$vid][$tid]);
            }
          }
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////////////////
// MENU CALLBACKS

/**
 * Menu calback for rendering a file system.
 *
 * @param $vid
 *   A vocabulary ID.
 * @param $tid
 *   A term ID.
 *
 * @return
 */
function file_browser_page($vid, $tid = NULL) {
  $vid = empty($vid) ? 'my' : $vid;
  if ($vid != 'my' && !is_numeric($vid)) {
    drupal_set_message('No vocabulary specified.', 'error');
    return '';
  }

  $tids = empty($tid) ? array() : array((integer)$tid);
  print theme('page', _file_browser_page($vid, $tids));
  exit;
}

/**
 * Menu callback for rendering a vocabulary via an Ajax request
 *
 * @param $vid
 *   A vocabulary ID.
 * @param $block
 *   ID of the browser. 'page' for the main browser or vocabulary
 *   IDs for the browsers in the drupal block area.
 */
function file_browser_ajax_voc($vid, $block = 'page') {
  if ($vid) {
    print _file_browser_ajax_voc($block, $vid, $block == 'page' ? TRUE : FALSE);
  }
  exit;
}

/**
 * Menu callback for rendering a term via an Ajax request.
 *
 * @param $tid
 *   A term ID.
 * @param $block
 *   ID of the browser. 'page' for the main browser or vocabulary
 *   IDs for the browsers in the drupal block area.
 */
function file_browser_ajax_term($tid, $block = 'page') {
  if ($term = db_fetch_object(db_query("SELECT t.* FROM {term_data} t WHERE t.tid = %d", $tid))) {
    print _file_browser_ajax_term($block, $term, $block == 'page' ? TRUE : FALSE);
  }
  exit;
}

//////////////////////////////////////////////////////////////////////////////
// FORM API

/**
 * Creates a new term form.
 */
function file_browser_newterm_form($form_state) {
  $form['vid'] = array(
    '#type' => 'hidden',
    '#id' => 'newterm-vid',
  );
  $form['parent'] = array(
    '#type' => 'hidden',
    '#id' => 'newterm-parent',
  );
  $form['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Create Term'),
    '#size' => 20,
    '#id' => 'newterm-name',
  );
  $form['weight'] = array(
    '#type' => 'hidden',
    '#title' => t('Weight'),
    '#value' => 0,
    '#id' => 'newterm-weight',
  );
  $form['newterm_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Create'),
    '#name' => 'newterm-submit',
  );
  $form['#attributes']['target'] = 'file_browser-newterm-submission-frame';

  return $form;
}

/**
 * Creats a file upload form.
 */
function file_browser_upload_form($form_state) {
  $form['tid'] = array(
    '#type' => 'hidden',
    '#value' => '0',
    '#id' => 'file-upload-tid',
  );
  $form['upload_0'] = array(
    '#type' => 'file',
    '#size' => 10,
  );
  $form['link'] = array(
    '#type' => 'markup',
    '#value' => '<a href="javascript:Drupal.file_browserAddFileWidget();">'. t('Add File') .'</a>',
  );
  if (FILE_BROWSER_OG_UPLOAD && module_exists('og')) {
    global $user;
    $groups = array();
    foreach ($user->og_groups as $nid => $group) {
      $groups[$nid] = $group['title'];
    }
    if (!empty($groups)) {
      $form['og_groups'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Audience'),
        '#options' => $groups,
        '#attributes' => array(),
      );
    }
  }
  $form['upload_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Upload'),
    '#name' => 'file-upload-submit',
    '#attributes' => array('disabled' => 'disabled', 'onClick' => 'return Drupal.file_browserFileUploadClick(this);'),
  );
  $form['#attributes']['enctype'] = 'multipart/form-data';
  $form['#attributes']['target'] = 'file_browser-upload-submission-frame';

  return $form;
}

//////////////////////////////////////////////////////////////////////////////
// SUBMIT HANDLERS

/**
 * Handle submission of the term create form
 */
function file_browser_newterm_form_submit($form, &$form_state) {
  if (!user_access('create terms')) {
    $errmsg = t('Permission denied, you do not have the correct access permissions.');
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('". $errmsg ."');</script>";
    exit;
  }
  // We do not allow empty terms.
  $form_state['values']['name'] = trim($form_state['values']['name']);
  if (empty($form_state['values']['name'])) {
    $errmsg = t('You cannot create empty terms.');
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('". $errmsg ."');</script>";
    exit;
  }
  // Check if the term is already created.
  $terms = taxonomy_get_term_by_name($form_state['values']['name']);
  /*
  if (in_array($form_state['values']['vid'], array_map(create_function('$t', 'return $t->vid;'), $terms))) {
    $errmsg = t('The term %term is already created.', array('%term' => $form_state['values']['name']));
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('". $errmsg ."');</script>";
    exit;
  }
  */
  $created = FALSE;
  foreach ($terms as $term) {
    if ($term->vid == $form_state['values']['vid']) {
      if ($form_state['values']['parent'] > 0) {
        $parents = taxonomy_get_parents($term->tid);
        if (in_array($form_state['values']['parent'], array_map(create_function('$t', 'return $t->tid;'), $parents))) {
          $created = TRUE;
        }
      }
      else {
        if (db_result(db_query('SELECT tid FROM {term_hierarchy} WHERE tid = %d AND parent = 0', $term->tid))) {
          $created = TRUE;
        }
      }
    }
  }
  if ($created) {
    $errmsg = t('The term %term is already created.', array('%term' => $form_state['values']['name']));
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('". $errmsg ."');</script>";
    exit;
  }
  // checking to see if we allow the term to be created (if Unfiled or Group Files then we do not allow)
  if ($form_state['values']['parent'] != 0) {
    $term = taxonomy_get_term($form_state['values']['parent']);
    if (!strcmp($term->name, "Unfiled")) {
      $errmsg = t('Permission denied, you cannot create a term below: '. $term->name);
      print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('". $errmsg ."');</script>";
      exit;
    }
  }
  // check that the vocabulary that it is being created under allows hierarchy
  $errmsg = _file_browser_allow_hierarchy($form_state['values']['vid'], $form_state['values']['parent']);
  if ($errmsg) {
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('". $errmsg ."');</script>";
    exit;
  }

  // saving the new term with all pertininent information from the submitted form
  $status = (taxonomy_save_term($form_state['values']));
  switch ($status) {
    case SAVED_NEW:
      $msg = '<div>'. t('Created term %name', array('%name' => $form_state['values']['name'])) .'</div>';
      break;
    case SAVED_UPDATED:
      $msg = '<div>'. t('Term %name updated', array('%name' => $form_state['values']['name'])) .'</div>';
      break;
  }

  // retrieve the new term from the system
  $term = taxonomy_get_term($form_state['values']['tid']);
  $term = clone($term);
  $childterms = taxonomy_get_tree($term->vid, $term->tid, -1, NULL);
  foreach ($childterms as $childterm) {
    if ($childterm) {
      $term = _file_browser_term_nodes($term, $childterm, NULL);
    }
  }
  $term = _file_browser_term_nodes($term, $term, NULL);
  $output .= _file_browser_term('page', $term, FALSE, in_array($term->tid, array()), TRUE);
  // make sure the output is sent back to the server so the data can be updated for the user
  print "<script type='text/javascript'>";
  print "parent.Drupal.file_browserDisplayTerm('page', '". $term->tid ."', '". (is_array($form_state['values']['parent']) ? 0 : $form_state['values']['parent']) ."','". $term->vid ."','". $output ."','". $msg ."','". $form_state['values']['name'] ."');";
  print "</script>";
  drupal_get_messages(); // calling because we do not want any set
  exit;
}

/**
 * Submits a new uploaded files.
 */
function file_browser_upload_form_submit($form, &$form_state) {
  global $user;

  if (!user_access('upload files')) {
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('Access Denied, you do not have the correct permissions');</script>";
    exit;
  }

  $tid = $form_state['clicked_button']['#post']['tid'];

  // Organic groups (og.module) integration: explicit audience selection.
  $og_groups = !empty($form_state['values']['og_groups']) ? $form_state['values']['og_groups'] : array();

  // Organic group vocabularies (og_vocab.module) integration: implicit
  // audience selection if the currently-selected taxonomy category is
  // related to an Og group.
  if (module_exists('og_vocab')) {
    if ($term = taxonomy_get_term($tid)) {
      if ($og_group = db_result(db_query('SELECT nid FROM {og_vocab} WHERE vid = %d', $term->vid))) {
        $og_groups[$og_group] = (string)$og_group;
      }
    }
  }

  $i = 0;
  do {
    if (($user->uid == 1 || user_access('upload files')) && ($upload = file_save_upload('upload_'. $i, file_get_validators()))) {
      $node_new = file_node_create(array('file' => $upload, 'taxonomy' => array($tid), 'og_groups' => $og_groups));

      // theme the node so we can display it on the screen to the user
      $output = _file_browser_node('page', $node_new, $visible = TRUE, $columns = TRUE);
      $msg = '<div>'. t('File %file has been uploaded successfully.', array('%file' => $node_new->title)) .'</div>';
      print "<script type='text/javascript'>";
      print "parent.Drupal.file_browserDisplayNode('page', '". $node_new->nid ."','". $tid ."','". $output ."','". $msg ."', '". check_plain($node_new->title) ."');";
      print "</script>";

    }
    $i++;
  } while (array_key_exists('upload_'. $i, $_FILES['files']['name']));

  // sending the notice message back if any occurred
  $notmsg = drupal_get_messages('notice');
  if (!empty($notmsg['notice'])) {
    print "<script type='text/javascript'>parent.Drupal.file_browserNoticeMsg('".'<div>'. implode('</div><div>', $notmsg['notice']) .'</div>'."');</script>";
  }

  // sending the error message back if any occurred
  $errmsg = drupal_get_messages('error');
  if (!empty($errmsg['error'])) {
    print "<script type='text/javascript'>parent.Drupal.file_browserErrorMsg('".'<div>'. implode('</div><div>', $errmsg['error']) .'</div>'."');</script>";
  }

  if (FILE_BROWSER_FOLDER_PROPERTIES) {
    // Update term and all parent terms.
    $term = taxonomy_get_term($tid);
    $parents = taxonomy_get_parents_all($tid);
    foreach ($parents as $parent) {
      $data = _file_browser_term_data($term->vid, $parent->tid);
      print "<script type='text/javascript'>parent.Drupal.file_browserUpdateTerm('file-folder-t". $parent->tid ."-bpage', '". $data['size'] ."', '". $data['count'] ."');</script>";
    }

    // Update the vocabulary data.
    $data = _file_browser_term_data($term->vid, 0);
    print "<script type='text/javascript'>parent.Drupal.file_browserUpdateTerm('file-folder-v". $term->vid ."-bpage', '". $data['size'] ."', '". $data['count'] ."');</script>";
  }

  // Clean up the file upload widget.
  print "<script type='text/javascript'>parent.Drupal.file_browserDelFileWidget();</script>";

  exit;
}

//////////////////////////////////////////////////////////////////////////////
// BLOCKS

/**
 * Creates a file upload block.
 *
 * @return
 *   A HTML section for the block.
 */
function _file_browser_upload() {
  if (!user_access('upload files'))
    return '';

  _file_browser_add_headers();
  $form = drupal_get_form('file_browser_upload_form');
  return theme('file_browser_upload', $form);
}

/**
 * Creates a new term block.
 */
function _file_browser_newterm() {
  if (!user_access('create terms'))
    return '';

  _file_browser_add_headers();
  $form = drupal_get_form('file_browser_newterm_form');
  return theme('file_browser_newterm', $form);
}

/**
 * Creates a browser block.
 *
 * @param $vid
 *   A vocabulary ID.
 * @param $expanded_tids
 *   An array of terms which should be expanded.
 */
function _file_browser_block($vid, $expanded_tids = array()) {
  // Hides block browsers on the main browser page.
  if (arg(0) == 'file_browser')
    return '';

  _file_browser_add_headers();
  $popupdiv .= '<div id="file-dropdown-b'. $vid .'" class="file-dropdown">';
  $popupdiv .= '<div id="file-dropdown-download-b'. $vid .'" class="file-dropdown-element">Download</div>';
  $popupdiv .= '<div id="file-dropdown-nodeview-b'. $vid .'" class="file-dropdown-element">View Post</div>';
  $popupdiv .= '</div>';
  $terms = _file_browser_build_terms($vid, $vid, $expanded_tids, FALSE);
  return theme('file_browser_block', compact('vid', 'popupdiv', 'terms'));
}

/**
 * Menu callback for rendering a file preview via an Ajax request
 *
 * @param $node
 *   A node object.
 */
function file_browser_preview($node = NULL) {
  _file_browser_add_headers();

  // Integration with og.module
  if (FILE_BROWSER_OG_PREVIEW && module_exists('og') && $node) {
    if (($groups = og_get_node_groups($node)) && !empty($groups)) {
      foreach ($groups as $gid => $group) {
        $groups[$gid] = l($group, 'node/'. $gid);
      }
    }
  }

  // Integration with location.module
  if (FILE_BROWSER_LOCATION_PREVIEW && module_exists('location')) {
    if (!empty($node->location) && is_array($node->location)) {
      $location = array('latitude' => $node->location['latitude'], 'longitude' => $node->location['longitude']);
    }
  }

  // Render a preview (thumbnail, or such) for those file formats that can provide one
  if (FILE_BROWSER_EMBED_PREVIEWS) {
    $file = $node->file;
    // Find a thumbnail for the file.
    $thumbnail = file_get_image($file, 'file_image_thumbnail', explode('x', FILE_IMAGE_THUMBNAIL_RESOLUTION));
    $thumbnail = $thumbnail ? $thumbnail : '<br /><span class="no-thumbnail">'. t('No thumbnail') .'</span><br />';
  }

  // File back references.
  $nodes = array();
  $result = db_query('SELECT fa.cid, n.* FROM {file_attachments} fa LEFT JOIN {node} n ON fa.nid = n.nid WHERE fa.fnid = %d', $node->nid);
  while ($n = db_fetch_object($result)) {
    if (node_access('view', $n)) {
      $nodes[] = $n;
    }
  }

  print theme('file_browser_preview', compact('node', 'groups', 'location', 'thumbnail', 'url_preview', 'nodes'));
  exit;
}

//////////////////////////////////////////////////////////////////////////////
// FILE BROWSER FUNCTIONS

/**
 * Builds browser page.
 *
 * @param $vid
 *   A vocabulary ID.
 * @param $expanded_tids.
 *   An array of therms which should be expanded.
 *
 * @return
 *   HTML output of the browser page.
 */
function _file_browser_page($vid, $expanded_tids = array()) {
  _file_browser_add_headers();

  $popupdiv = '<div id="file-dropdown-bpage" class="file-dropdown">';
  $popupdiv .= '<div id="file-dropdown-download-bpage" class="file-dropdown-element">Download</div>';
  $popupdiv .= '<div id="file-dropdown-preview-bpage" class="file-dropdown-element">Preview</div>';
  $popupdiv .= '<div id="file-dropdown-nodeview-bpage" class="file-dropdown-element">View Post</div>';
  $popupdiv .= '</div>';
  $popupdiv .= '<form id="file-node-url-form"><input id="file-node-url" type="hidden" value="'. url('node/') .'" /><input id="file-download-url" type="hidden" value="'. url('file/') .'" /></form>';

  $terms = _file_browser_build_terms('page', $vid, $expanded_tids);
  $terms = !empty($terms) ? $terms : t('No vocabularies configured.');
  return theme('file_browser_page', compact('vid', 'popupdiv', 'terms'));
}

/**
 * Creates a vocabualry via an Ajax request.
 *
 * @param $block
 *   'page' or vocbulary ID to distinguish which browser is making a request.
 * @param $vid
 *   A vocabulary ID.
 * @param $columns
 *   If true, the size and date should be displayed.
 *
 * @return
 *   The HTML block for a requested vocabulary.
 */
function _file_browser_ajax_voc($block, $vid, $columns) {
  if ($vid) {
    if ($terms = taxonomy_get_tree($vid, 0, -1, 1)) {
      foreach ($terms as $term) {
        $term = clone($term);
        $childterms = taxonomy_get_tree($vid, $term->tid, -1, NULL);
        foreach ($childterms as $childterm) {
          $term = _file_browser_term_nodes($term, $childterm, NULL);
        }
        $term = _file_browser_term_nodes($term, $term, NULL);
        $output .= _file_browser_term($block, $term, FALSE, in_array($term->tid, array()), $columns);
      }
    }
  }
  return $output;
}

/**
 * Creates a term via an Ajax request.
 *
 * @param $block
 *   'page' or vocbulary ID to distinguish which browser is making a request.
 * @param $term
 *   A term object.
 * @param $columns
 *   If true, the size and date should be displayed.
 *
 * @return
 *   The HTML block for a requested term.
 */
function _file_browser_ajax_term($block, $t, $columns) {
  $output = "";
  // get the terms that are on this level
  if ($terms = taxonomy_get_tree($t->vid, $t->tid, -1, 1)) {
    foreach ($terms as $term) {
      $term = clone($term);
      $childterms = taxonomy_get_tree($term->vid, $term->tid, -1, NULL);
      foreach ($childterms as $childterm) {
        $term = _file_browser_term_nodes($term, $childterm, NULL);
      }
      $term = _file_browser_term_nodes($term, $term, NULL);
      $output .= _file_browser_term($block, $term, FALSE, in_array($term->tid, array()), $columns);
    }
  }

  foreach (_file_browser_term_nodes($t, $t, 0) as $node) {
    if ($node) {
      $output .= _file_browser_node($block, $node, FALSE, $columns);
    }
  }

  return $output;
}

/**
 * Creates a browser term.
 *
 * @param $block
 *   'page' or vocbulary ID to distinguish which browser is making a request.
 * @param $term
 *   A term object.
 * @param $visible
 *   Is true if a term is visible.
 * @param $expanded
 *   Is true, if a term is expanded.
 * @param $columns
 *   If true, the size and date should be displayed.
 *
 * @return
 *   The HTML block for a requested term.
 */
function _file_browser_term($block, $term, $visible = TRUE, $expanded = FALSE, $columns = TRUE) {
  if (FILE_BROWSER_HIDE_EMPTY && $term->tid && empty($term->nodes)) {
    $children = taxonomy_get_children($term->tid, $term->vid);
    if (empty($children)) {
      return '';
    }
  }

  $name = check_plain($term->name);
  $size = array_sum(array_map(create_function('$node', 'return is_object($node->file) ? $node->file->size : 0;'), $term->nodes));
  $size = FILE_BROWSER_FOLDER_PROPERTIES ? format_size($size) : '&mdash;';
  $is_vocab = $term->tid ? FALSE : TRUE;
  $count = FILE_BROWSER_FOLDER_PROPERTIES ? array_sum(array_map(create_function('$node', 'return is_object($node->file) ? 1 : 0;'), $term->nodes)) : '&mdash;';
  $xhtml_id = empty($term->tid) ? 'file-folder-v'. $term->vid .'-b'. $block : 'file-folder-t'. $term->tid .'-b'. $block;
  $xhtml_class = 'file-folder'. (!empty($term->module) ? ' '. $term->module : '');
  $hierarchy = _file_browser_allow_hierarchy($term->vid, $term->tid) ? FALSE : TRUE;

  return theme('file_browser_term', compact('size', 'count', 'is_vocab', 'xhtml_id', 'xhtml_class', 'hierarchy', 'name', 'visibile', 'expanded', 'columns'));
}

/**
 * Creates a browser node.
 *
 * @param $block
 *   'page' or vocbulary ID to distinguish which browser is making a request.
 * @param $node
 *   A node object.
 * @param $visible
 *   Is true if a term is visible.
 * @param $columns
 *   If true, the size and date should be displayed.
 *
 * @return
 *   The HTML block for a requested node.
 */
function _file_browser_node($block, $node, $visible = TRUE, $columns = TRUE) {
  $title = check_plain($node->title);
  $file = $node->file;
  $file->name = $node->title;
  $id = 't'. $node->tid .'-n'. $file->nid .'-b'. $block;
  switch (FILE_BROWSER_FILE_LINK) {
    case 'file':
      $url = 'file/'. $node->nid .'/download/'. $node->vid;
      break;
    case 'node':
      $url = 'node/'. $node->nid;
      break;
    case 'nolink':
      $url = NULL;
      break;
  }
  $icon = file_mime_icon_for($file->type, file_mime_description_for($file->type));
  $date = format_date($node->changed, 'small');
  $size = format_size($file->size);

  return theme('file_browser_file', compact('file', 'id', 'icon', 'title', 'url', 'date', 'size', 'visibile', 'columns'));
}

/**
 * Build the terms that will be displayed
 *
 * @param $block
 *   'page' or vocbulary ID to distinguish which browser is making a request.
 * @param $vid
 *   A vocabulary ID.
 * @param $expanded_tids.
 *   An array of terms which should be expanded.
 * @param $columns
 *   If true, the size and date should be displayed.
 *
 * @return
 *   The HTML block for a terms.
 */
function _file_browser_build_terms($block, $vid, $expanded_tids = array(), $columns = TRUE) {
  global $user;

  $output = '';
  if ($vid == 'my') {
    $terms = array_filter(variable_get('file_browser_vocabularies', array()), 'is_string');
    if (module_exists('og_vocab') && FILE_BROWSER_OG_VOCABULARIES) {
      foreach (array_keys($user->og_groups) as $nid) {
        $result = db_query('SELECT vid FROM {og_vocab} WHERE nid = %d', $nid);
        while ($vid = db_result($result)) {
          if (!array_key_exists($vid, $terms)) {
            $terms[$vid] = (string)$vid;
          }
        }
      }
    }
    $vocabularies = taxonomy_get_vocabularies('file');
    foreach ($terms as $i => $term) {
      $terms[$i] = $vocabularies[$term];
    }
  }
  else {
    $terms = taxonomy_get_tree($vid, 0, -1, 1);
  }
  if ($terms) {
    foreach ($terms as $term) {
      $term = clone($term);
      $childterms = taxonomy_get_tree($term->vid, $term->tid ? $term->tid : 0, -1, NULL);
      foreach ($childterms as $childterm) {
        if ($childterm) {
          $term = _file_browser_term_nodes($term, $childterm, NULL);
        }
      }
      $term = _file_browser_term_nodes($term, $term, NULL);
      $output .= _file_browser_term($block, $term, FALSE, in_array($term->tid, $expanded_tids), $columns);
    }
  }
  return $output;
}

/**
 * Returns either the term object or an array of nodes for the term
 *
 * @param $term
 *   A term oblect.
 * @param $childterm
 *   A children term object
 * @param $getnodes
 *   A flag specifying if a nodes should be returned.
 *
 * @return
 *   A term object or term's nodes.
 */
function _file_browser_term_nodes($term, $childterm, $getnodes = NULL) {
  if ($nodes = _file_browser_select_nodes($childterm->tid ? array($childterm->tid) : array(), 0, 'n.sticky DESC, n.title ASC, n.created DESC')) {
    while ($node = db_fetch_object($nodes)) {
      $node = node_load($node->nid);
      if ($node = clone((object)$node)) {
        if ($node->type == 'file' && !empty($node->file)) {
          $term->nodes[] = $node;
        }
      }
    }
  }

  if (!$term->nodes) {
    $term->nodes = array();
  }
  return is_null($getnodes) ? $term : $term->nodes;
}

/**
 * Stripped down file taxonomy specific implementation of
 * taxonomy_select_nodes function
 *
 * @param $tids
 *   An array of terms.
 * @param $depth
 *   A txonomy depth
 * @param $order
 *   A sql order statement.
 *
 * @return
 *   A database query result.
 */
function _file_browser_select_nodes($tids = array(), $depth = 0, $order = 'n.sticky DESC, n.created DESC') {
  if (count($tids) > 0) {
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {
      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
    }

    $str_tids = implode(',', call_user_func_array('array_merge', $descendant_tids));
    if ($str_tids) {
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1 AND n.moderate = 0 ORDER BY '. $order;
      $sql = db_rewrite_sql($sql);
      $result = db_query($sql);
    }
  }
  return $result;
}

//////////////////////////////////////////////////////////////////////////////
// AUXILIARY FUNCTIONS

/**
 * Add relevant header files required by the system to function
 */
function _file_browser_add_headers() {
  static $initialized = FALSE;
  if (!$initialized) {
    $initialized = TRUE;
    drupal_add_css(drupal_get_path('module', 'file_browser') .'/file_browser.css');
    drupal_add_js(drupal_get_path('module', 'file_browser') .'/file_browser.js');

    // Cluetip for metadata.
    drupal_add_css(drupal_get_path('module', 'file') .'/jquery/cluetip/jquery.cluetip.css', 'module');
    drupal_add_js(drupal_get_path('module', 'file') .'/jquery/cluetip/jquery.dimensions.js', 'module');
    drupal_add_js(drupal_get_path('module', 'file') .'/jquery/cluetip/jquery.cluetip.js', 'module');

    // Thickbox.
    drupal_add_css(drupal_get_path('module', 'file') .'/jquery/thickbox/thickbox.css', 'module');
    drupal_add_js('var tb_pathToImage = "'. base_path() . drupal_get_path('module', 'file') .'/jquery/thickbox/loadingAnimation.gif";', 'inline');
    drupal_add_js(drupal_get_path('module', 'file') .'/jquery/thickbox/thickbox.js', 'module');

    // Translations to javascript.
    drupal_add_js(array('file_browser' => array('no_file_selected' => t('No file selected.'))), 'setting');
  }
}

/**
 * Determine whether or not the vocabulary is allowed a hierarchy or not.
 * @param $vid
 *   A vocabulary ID
 * @param $tid
 *   A parent term ID
 */
function _file_browser_allow_hierarchy($vid, $tid) {
  // check that the vocabulary that it is being created under allows hierarchy
  $vocabularies = taxonomy_get_vocabularies('file');
  $voc = $vocabularies[$vid];
  if ($tid > 0 && ($voc->tags == 1 || $voc->hierarchy == 0)) {
    return t('Permission denied. Vocabulary does not support hierarchies');
  }
  if (preg_match('/Group Files/', $voc->name)) {
    return t('Permission denied. You may only create new folders under Home Folder');
  }
}

/**
 * Gets term or vocabulary nodes count and size.
 *
 * @param $vid
 *   A vocabulary ID.
 * @param $tid
 *   A term ID.
 *
 * @return
 *   An array with the nodes count and size.
 */
function _file_browser_term_data($vid, $tid) {
  $t = (object)array();
  $childterms = taxonomy_get_tree($vid, $tid, -1, NULL);
  foreach ($childterms as $childterm) {
    if ($childterm) {
      $t = _file_browser_term_nodes($t, $childterm, NULL);
    }
  }
  if ($tid != 0) {
    $term = taxonomy_get_term($tid);
    $t = _file_browser_term_nodes($t, $term, NULL);
  }
  $size = array_sum(array_map(create_function('$node', 'return is_object($node->file) ? $node->file->size : 0;'), $t->nodes));
  $count = array_sum(array_map(create_function('$node', 'return is_object($node->file) ? 1 : 0;'), $t->nodes));
  return array('size' => format_size($size), 'count' => $count);
}

